---
title: "Latent Markov Models for modeling customer spending dynamics"
description: |
  In this post we will apply Latent Markov Models to model the customers portfolio 
  composition of a retailer. To fit the models we will use the R package LMest.
categories:
  - Econometrics
  - Latent Markov Models
  - Marketing
author: 
    name: Alessandro Ghiretti
    url: 
    affiliation: 
    affiliation_url: 
bibliography: references.bib
date: "`r Sys.Date()`"
output: 
  distill::distill_article:
      toc: true
      toc_depth: 3
repository_url: https://github.com/rstudio/distill
self_contained: false
nocite: | 
  @WOODSIDE1996189, @bartolucci2012latent, @bartolucci2010overview, @LMest, @bookleeflang2017advanced
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(janitor)
library(LMest)
library(rmarkdown)
library(corrplot)
library(patchwork)
```


# Introduction
Market or customer segmentation refers to the division of customers or potential customers of a given market into homogeneous groups. The idea is that customers belonging to the same group will common characteristics and their response  to marketing activities and initiatives will be almost the same.
Customer segmentation can be performed in different ways, for example a very basic method is to divide customers into groups on the basis of they spending, LTV or number of visits to a store. Where in the first two cases the aim is to identify groups of customers with different profitability and target them with different campaigns, discounts or promotions.

In practice other variables than the number of visits or the spending are taken into account, for example socio-economic variables are often included  as it is well known that factors such as age, lifestyle and status have a great impact on the customer behavior. Despite the number of groups in which we want to segment our customers is often known a priori it might happen that there exists hidden partitions that we ignore. In this case statistical techniques can be adopted to decide the number of groups that achieve the best homogeneity between members.

Once customers are aggregated into different groups the interest might be in monitoring the evolution of these groups over time. For example having collected a sample of customers and having divided them into four groups according to their spending the company would like to know:

* What is the probability that a customer belongs to the a given group?
* What is the probability that an high spender becomes a low spender?
* What is the effect of age on these probabilities?

To answer these kind of questions we will propose an approach based on Latent Markov Models. In the following we will review the theory behind Latent Markov models subsequently apply them to model the customer spending dynamics

## Latent Markov Models



## Modeling customer spending dynamics via Markov Models
In this section we apply LMM to model the 


### Data description
The dataset that we consider is The Complete Journey dataset freely available from Dunn Humby. According to the description of the data provider the dataset contains household level transactions over two years from a group of 2,500 households who are
frequent shoppers at a retailer. It contains all of each householdâ€™s purchases, not just those from a limited number of categories. For certain households, demographic information as well as direct marketing contact
history are included.


### Data analysis
```{r}
setwd("C:\\Users\\USR02193\\OneDrive - Chiesi Farmaceutici S.p.A\\Documents\\Marketing\\Markov")
demo <-  read.csv("hh_demographic.csv")  
transactions <- read.csv("transaction_data.csv") 
```

We start by importing the data into R into two data.frame the demo which contains the demographical information of the customers and the transactions which contains the transactions performed by every customer in the retail in the last two years. We use janitor to clean and standardize the name of the columns.

```{r echo = TRUE, eval =TRUE}
# clean column names
colnames(transactions) <- make_clean_names(colnames(transactions))
colnames(demo) <- make_clean_names(colnames(demo))
```

Since we are dealing with temporal data the most natural thing is to retain the information provided by the time dimension and apply a longitudinal Latent Markov Model. Therefore We proceed by constructing a panel. To do so we divide the data into quarters each one composed of 120 days for a total of four quarters per year. 

```{r echo = TRUE, eval =TRUE}
# build the variable indicating the quarter
quarter <- rep(seq(1:8), each = 120)
day <- seq(1:length(quarter))
time_quarter <- data.frame(quarter,day)

# assign the transactions to the corresponding quarter by joining on the day
adjust_transactions <- transactions %>% left_join(time_quarter, by = c("day" = "day"))
```

Next for each customer we obtain the total spending per quarter which will be used to score the customer profitability

```{r echo = TRUE, eval =TRUE}
customer_quarter <- adjust_transactions %>% 
  # join with demographics data
  left_join(demo, by = c("household_key" = "household_key")) %>% 
  # group by customer Id
  group_by(household_key, quarter) %>% 
  # obtain total spend per customer
  summarise(tot_spend = sum(sales_value)) %>% 
  ungroup()
```

In order assign a score to every customer we compare total spending in each quarter with the quartile of the quarterly total spending distribution. Next, we assign a score $S$ between 1 and 4, where the two extreme values denote respectively low spenders and high spender customers. In particular we have

* 1) Low spenders, $S=1$ 

* 2) Middle-low spenders, $S=2$ 

* 3) Middle-high spenders, $S=3$ 

* 4) High spenders: $S = 4$,


whit score function
$$
\begin{aligned}
S = \begin{cases}
& 1 \quad \text{if}, \; I(spending_{iq} \leq Q_{1}(spending_{q})) = 1  \\
& 2 \quad \text{if}, \; I(Q_{1}(spending_{q}) < spending_{iq} \leq Q_{2}(spending_{q})) = 1 \\
& 3 \quad \text{if}, \; I(Q_{2}(spending_{q}) < spending_{iq} \leq Q_{3}(spending_{q})) = 1 \\
& 4 \quad \text{if}, \; I(spending_{iq} > Q_{3}(spending_{q})) = 1  
\end{cases}
\end{aligned}
$$

where $spending_{iq}$ denotes the spending of the $i$th customer in quarter $q$, $Q_{j}(spending_{q})$ denote the $j$th quartile of the spending distribution in quarter $q$ and $I(\cdot)$ is the indicator function which results.
The next chunk of code compute the quartiles and assign the scores to each customer.

```{r echo = TRUE, eval =TRUE}
# compute quartiles
quantiles <- customer_quarter %>% 
  group_by(quarter) %>% 
     summarise(q1 = quantile(tot_spend,0.25),
               q2 = quantile(tot_spend,0.5),
               q3 = quantile(tot_spend,0.75))



# assign score to each customer
# in this loop scores are assigned to each customer for each quarter
s <- c()
k <- c()
q <- c()
score <- s
key <- k
quarter <- q

for(j in seq(1:6)){
  ll <- customer_quarter %>% filter(quarter == j)
  qq <- quantiles %>% filter(quarter == j)
  
for(i in 1:nrow(ll)){
  k[i] <- ll$household_key[i]
  q[i] <- j
  if(ll$tot_spend[i] <= qq[2]){
    s[i] <- 1
    }else if(ll$tot_spend[i] > qq[2] & ll$tot_spend[i] <= qq[3]){
      s[i] <- 2
        }else if(ll$tot_spend[i] > qq[3] & ll$tot_spend[i] <= qq[4]){
        s[i] <- 3}
      else if(ll$tot_spend[i] > qq[4]) {s[i] <- 4}
}
  
quarter <- c(quarter,q)
score <- c(score,s)
key <- c(key,k)
}

# obtain the scores given to the customers over the different quarters
quarter_scores <- data.frame(household_key = key, score,  quarter)

# bind scores to the customers spend
customer_quarter <- customer_quarter %>% 
  left_join(quarter_scores, by = c("household_key" = "household_key", "quarter" = "quarter")) %>% 
  dplyr::select(-c("tot_spend")) %>% data.frame()


```

Having assigned the score to each customer we proceed to join the results with the socio-economic variables and prepare the data for model fitting. In particular we remove the observations with missing data, convert the variables to factors and consider only the customers that performed a purchase at least once every quarter. This last adjustment is performed in order to have a balanced panel.

```{r, echo = TRUE, eval =TRUE}
# bind demographic info and remove customers with missing values
data_fit <- customer_quarter %>% 
  # join tables
  left_join(demo, by = c("household_key")) %>% 
  # remove households with missing values
  drop_na()

# rename variables for model fitting
c_name <- colnames(data_fit)
nc <- ncol(data_fit)
c_name[3] <- paste("Y",sep ="",colnames(data_fit)[3])
c_name[4:nc] <- paste(paste("X",seq(1:(nc-3)),sep=""),colnames(data_fit)[4:nc],sep = "")
colnames(data_fit) <- c_name

# convert explanatory variables into factors
response <-  colnames(data_fit)[4:nc]
data_fit[response] <- lapply(data_fit[response], factor)

# extract customers which have at least one expense in each quarter
idx = data_fit %>% group_by(household_key) %>% 
  # obtain number of quarters per household
  summarise(n = n()) %>% ungroup() %>%  
  # filter out households
  filter(n==6) %>% 
  # select  hoousehold key and transform it to a vector
  dplyr::select(household_key) %>% as.vector()

data_fit <- data_fit %>% filter(household_key %in% idx$household_key)
```

After the cleaning the data comprises 801 customers each of them observed for one quarter.

## Fitting LMM model.

In order to fit the LMM model we will use the LMest ([LMest]) package, developed by F. Bartolucci, F. Pennoni and .


We will consider three different models.

* $\mathcal{M}_{1}$: time homogeneous LMM with no covariates. This is the simplest models and transition probabilites are not allowed to change over time.

* $\mathcal{M}_{2}$: time heterogeneous LMM with no covariates. In this case no explanatory variables are included in the model but the transition probabilities are allowed to vary in time

* $\mathcal{M}_{3}$: time heterogeneous LMM with covariates. This is an extension of model $\mathcal{M}_{2}$ where we include socio-economic descriptors are covariates


Despite it is possible to add covariates both in the equation which scribe the evolution of the latent state and in the equation which describe the evolution of the observed series this discouraged as suggested by [@bartolucci2012latent]. The main reasons are that the resulting model might be too complex to interpret and that the number of parameters might increase too much leading to unreliable estimates in the optimization process.


We proceed do define the formulas for every model and to fit them

```{r eval = TRUE, results = "hide"}
#  define formulas for model fitting
fmBasic = lmestFormula(data = data_fit,response = "Y")
fmLatent = lmestFormula(data = data_fit, response = "Y", LatentInitial = "X")
fmLatent2 = lmestFormula(data = data_fit, response = "Y")


#set.seed(9845)
# fit the three different models
# M1
mod1 <- lmest(responsesFormula = fmBasic$responsesFormula,
             index = c("household_key","quarter"),
             data = data_fit, k = 4, modBasic = 1)
#M2
mod2 <- lmest(responsesFormula = fmLatent$responsesFormula,
             index = c("household_key","quarter"),
             data = data_fit, k = 4, modBasic = 0)
#M3
mod3 <- lmest(responsesFormula = fmLatent2$responsesFormula,
              latentFormula = fmLatent2$latentFormula,
             index = c("household_key","quarter"),
             data = data_fit, k = 4)

```

We start by considering the BIC, AIC for M1 and M2

```{r}
fit <- data.frame(model = c("M1", "M2"), aic = c(mod1$aic,mod2$aic), bic = c(mod1$bic,mod2$bic))
fit %>%  paged_table()
```


We start by comparing the prior probabilities obtained by the two models without covariates.
Prior probabilities represents the probability that a customer belongs to a certain class.

```{r}
prior <- rbind(mod1$piv,mod2$piv) %>% data.frame()
colnames(prior) <- c("low spender", "middle-low spender", "middle-high spender", "high spender")
prior <-  cbind(model = c("M1", "M2"),prior)

prior %>%  paged_table()
```

The prior probabilities estimated using from the two models appears pretty different. According to M1 the probability of a customer to belong to the low spenders group is almost 43%, while according to M2 this probability is only 26%.
Conversely M2 shows an increase in the estimated prior probabilities associate to the middle-low spender and middle-high spenders groups, nevertheless the prior probability estimated by the two models for the high spender group is almost the same around 40%.



To understand the dynamics of the customer segments we can analyze the transition probabilities estimated by the two models

```{r}
# obtain transition probabilities for model 1
trans_m1 <- data.frame(mod1$Pi)
# rename and bind columns 
colnames(trans_m1) <- rep(c("p1","p2","p3","p4"),6)
trans_m1 <- rbind(trans_m1[,1:4],
                  trans_m1[,5:8],
                  trans_m1[,9:12],
                  trans_m1[,13:16],
                  trans_m1[,17:20], 
                  trans_m1[,21:24])

# obtain transition probabilities for model2
trans_m2 <- data.frame(mod2$Pi)
# rename and bind columns
colnames(trans_m2) <- rep(c("p1","p2","p3","p4"),6)

trans_m2 <- rbind(trans_m2[,1:4],
                  trans_m2[,5:8],
                  trans_m2[,9:12],
                  trans_m2[,13:16],
                  trans_m2[,17:20], 
                  trans_m2[,21:24])
```


```{r}
trans_m1 %>% filter(t==2) %>% 
  dplyr::select(p1,p2,p3,p4) %>%  as.matrix() %>% corrplot()
```


